{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"CLI tool and libraries to<code>scan</code>, <code>parse</code> and <code>render</code><code>Jetpack Compose</code> compiler <code>metrics</code>as beautiful <code>HTML</code> &amp; <code>JSON</code> reports <p>Fastforward?</p> <p>Jump to <code>How to use</code></p>"},{"location":"#why-mendable","title":"Why Mendable?","text":"<p>If any of the following sounds like one of your requirements:</p> <ol> <li><code>Scan</code> and find <code>Compose Compiler metrics</code> files in a directory</li> <li><code>Parse</code> <code>metrics files</code> into usable, operable <code>Kotlin objects</code></li> <li><code>Render</code> metrics as <code>HTML</code> / <code>JSON</code> reports</li> <li>Do all of the above with a single command in <code>CLI</code> as well?</li> </ol> <p>then <code>Mendable</code> has you covered.</p> <p><code>Mendable</code> <code>scans</code> &amp; <code>parses</code> <code>Compose compiler</code> generated <code>metrics files</code> and renders them as beautiful <code>HTML</code>/<code>JSON</code> reports.<code>Mendable</code> focuses on problematic <code>composable methods</code>, highlighting issues causing parts and filtering out non-problematic ones. It consolidates reports from multiple <code>modules</code> into a single, well-organized <code>HTML</code> page or a <code>JSON</code> report, streamlining the <code>workflow</code> of finding/fixing <code>unstable</code> <code>Composables</code>.</p> <p>The <code>scan</code>, <code>parse</code> &amp; <code>report</code> parts of <code>Mendable</code> are published as artifacts on <code>Maven Central</code>. If you are building any <code>tooling</code>/<code>libraries</code> arround Compose Compiler Metrics these capabilities of <code>Mendable</code> could give you a significant headstart.</p> And your <code>HTML</code> report should look something like this <p></p>"},{"location":"howto/","title":"How to use <code>Mendable</code>","text":"<p><code>Mendable</code> can primarily be used in two different ways:</p> <ol> <li>As a <code>CLI</code> tool</li> <li>As a set of library dependencies in your <code>Kotlin</code> / <code>Java</code> projects</li> </ol>"},{"location":"howto/Cli/","title":"Using <code>Mendable</code> as a <code>CLI</code> tool","text":"<p>Download</p> <p></p> <p>It is very straightforward. Download and execute the <code>jar</code> file while pointing it to the directory which contains all the Compose-compiler generated metrics files.</p> <p>Mendable will take care of the rest. It will figure out metrics files of individual <code>modules</code>, <code>parse</code> them, <code>compute</code> and <code>generate</code> a beautiful <code>report</code> for you.</p> <p>Info</p> <p><code>Mennable</code> does not generate <code>Compose compiler</code> <code>Metrics</code>, you would have to generate them and point <code>Mendable</code> to it's output. Read here to know How to generate Compose Compiler Metrics. The following steps assumes that you have a similar <code>gradle</code> setup as to the one described in the link above.</p>"},{"location":"howto/Cli/#generate-report-with-a-single-command","title":"\u2728 Generate report with a single command \u2728","text":"<p>Download and place the <code>jar</code> file in the same folder which contains all the generated Compose compiler metrics (should be <code>YourProject/build/compose_metrics</code>). And then execute the <code>jar</code> file with the following <code>command</code>.</p> <pre><code>java -jar mendable-app.jar\n</code></pre> <p>After executing this <code>command</code> there should be <code>index.html</code> file generated in the same folder, which will contain the combined metrics of all the modules.</p>"},{"location":"howto/Cli/#configuration","title":"\u2728Configuration \u2728","text":"<p>While the above method is the easiest, and should work fine for most of the use cases, <code>Mendable</code> also supports some configuration. The following are the supported options via <code>CLI arguments</code>.</p> <pre><code>java -jar mendable.jar\n    --scanPaths, -i               [Default value : &lt;Current working dir&gt;] -&gt; Paths to the directories containing the composables.txt files (for multiple paths use this format \"path1 path2\")\n    --scanRecursively, -sr        [Default value : false]                 -&gt; Weather to scan the directory recursively or not\n    --outputPath, -o              [Default value : &lt;Current working dir&gt;] -&gt; Report output directory\n    --outputName, -oName          [Default value : \"index\"]               -&gt; Name of the output file\n    --exportType, -eType          [Default value : \"html\"]                -&gt; Export type of the output file (html/json)\n    --reportType, -rType          [Default value : \"all\"]                 -&gt; Report type of the output file (all, with_warnings)\n    --help, -h                                                            -&gt; Usage info\n</code></pre> <p>For example :</p> macOSWindows <pre><code>java -jar mendable.jar\n    --scanRecursively \\\n    -i \"/Users/username/Desktop/Your-project/build/compose_metrics /Users/username/Desktop/Other-project/build/compose_metrics\" \\\n    -o /Users/username/Desktop/Reports \\\n    -oName Your-project-metrics \\\n    -eType html \\\n    -rType all \\\n</code></pre> <pre><code>java -jar mendable.jar `\n    --scanRecursively `\n    -i \"/Users/username/Desktop/Your-project/build/compose_metrics /Users/username/Desktop/Other-project/build/compose_metrics\" `\n    -o /Users/username/Desktop/Reports `\n    -oName Your-project-metrics `\n    -eType html `\n    -rType all `\n</code></pre> <p>For the above command, files will be <code>read</code> from <code>/Users/username/Desktop/Your-project/build/compose_metrics</code> and <code>/Users/username/Desktop/Other-project/build/compose_metrics</code> by recurisvely going through every directory in these directories and the <code>output</code> file will be <code>saved</code> at <code>/Users/username/Desktop/Reports/Your-project-metrics.html</code>.</p> <p>Note</p> <p>While <code>Mendable</code> has capabilities to <code>scan</code>/<code>parse</code> all the different types of <code>metrics files</code>. The <code>HTML</code>/<code>JSON</code> report only targets the <code>&lt;module&gt;-composables.txt</code> files.</p> And your <code>HTML</code> report should look something like this <p></p>"},{"location":"howto/Cli/#other-things-to-know","title":"Other things to know","text":"<ul> <li> <p>Clicking on the composable's name in the <code>HTML</code> report will copy the name to the <code>clipboard</code></p> </li> <li> <p>You can build an executable <code>jar</code> yourself by executing the following command in the root of the mendable project</p> </li> </ul> <pre><code>./gradlew mendable-app:clean mendable-app:jar\n</code></pre>"},{"location":"howto/Library/","title":"Using <code>Mendable</code> as a <code>Library</code>","text":"<p>Individual subcomponents of <code>Mendable</code> are published as <code>Maven artifacts</code> on <code>MavenCentral</code>. These are good old Java libraries, which you can consume in any <code>tooling</code> or <code>library</code> project you might be building around <code>Jetpack Compose</code> <code>Compiler</code> <code>Metrics</code>.</p>"},{"location":"howto/Library/#artifacts","title":"Artifacts","text":"<p>The whole functionality of <code>Mendable</code> has been split into 3 major modules, based on your requirements, you can pick and choose what you want.</p> <ol> <li><code>:scanner</code> : Scan a directory to find all (or some) of the <code>Compose Compiler Metrics</code> files.</li> <li><code>:parser</code> : Parse raw <code>Compose Compiler Metrics</code> files into operable <code>Kotlin</code> <code>objects</code>.</li> <li><code>:mendable</code> : Is a high-level library which scans, parses, and renders these reports as <code>HTML</code>/<code>JSON</code> reports by using <code>:scanner</code> &amp; <code>:parser</code> under the hood.</li> </ol>"},{"location":"howto/Library/#setup","title":"Setup","text":"<p>Add the following dependencies to your project</p> <pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.jayasuryat.mendable:scanner:0.7.0\")\n    implementation(\"com.jayasuryat.mendable:parser:0.7.0\")\n    implementation(\"com.jayasuryat.mendable:mendable:0.7.0\")\n}\n</code></pre>"},{"location":"howto/Library/#usages","title":"Usages","text":""},{"location":"howto/Library/#scanner","title":"<code>:scanner</code>","text":"<p>All the functionality of the <code>scanner</code> module is exposed as <code>top-level</code> <code>functions</code>. There are individual functions which scan for the individual report type, and a consolidating function which scans for all types of report files and returns them.</p> <pre><code>// import com.jayasuryat.mendable.scanner.scanForComposableSignaturesReportFiles\n// import com.jayasuryat.mendable.scanner.scanForClassStabilityReportFiles\n// import com.jayasuryat.mendable.scanner.scanForComposableTabularReportFiles\n// import com.jayasuryat.mendable.scanner.scanForModuleMetricsFiles\n// import com.jayasuryat.mendable.scanner.scanForAllComposeCompilerMetricsFiles\n\n// &lt;module-name&gt;-composables.txt files\nval composables: List&lt;ComposableSignaturesReportFile&gt; =\n    scanForComposableSignaturesReportFiles(\n        directory = directory,\n        scanRecursively = true,\n    )\n\n// &lt;module-name&gt;-classes.txt files\nval classes: List&lt;ClassStabilityReportFile&gt; =\n    scanForClassStabilityReportFiles(directory)\n\n// &lt;module-name&gt;-composables.csv files\nval tabularReport: List&lt;ComposableTabularReportFile&gt; =\n    scanForComposableTabularReportFiles(directory)\n\n// &lt;module-name&gt;-module.json files\nval moduleMetrics: List&lt;ModuleMetricsFile&gt; =\n    scanForModuleMetricsFiles(directory)\n\n// Combines all the 4 types above\nval allReports: List&lt;ComposableSignaturesReportFile&gt; =\n    scanForAllComposeCompilerMetricsFiles(directory)\n</code></pre>"},{"location":"howto/Library/#parser","title":"<code>:parser</code>","text":"<p><code>:parser</code> exposes <code>*.parse()</code> <code>extension method</code> on all the types of report-files, which returns the <code>parsed</code> report.</p> <p>Alternatively <code>:parser</code> also exposes individual <code>Parsers</code> which can <code>parse</code> all the different type of reports. This could come in handy if you want to reuse the <code>parser</code> <code>instace</code> while parsing mulitple files.</p> ExtensionParser instance <pre><code>// import com.jayasuryat.mendable.parser.parse\n\nval composables: ComposableSignaturesReportFile = TODO()\nval parsedComposables: ComposableSignaturesReport = composables.parse()\n\nval classes: ClassStabilityReportFile = TODO()\nval parsedClasses: ClassStabilityReport = classes.parse()\n\nval tabularReport: ComposableTabularReportFile = TODO()\nval parsedTabularReport: ComposableTabularReport = tabularReport.parse()\n\nval moduleMetrics: ModuleMetricsFile = TODO()\nval parsedModuleMetrics: ModuleMetrics = moduleMetrics.parse()\n\nval someMetricsFile: ComposeCompilerMetricsFile = TODO()\nval parsedMetrics: ComposeCompilerMetrics = someMetricsFile.parse()\n</code></pre> <pre><code>// com.jayasuryat.mendable.parser.getComposableSignaturesReportFileParser\n// com.jayasuryat.mendable.parser.getClassStabilityReportFileParser\n// com.jayasuryat.mendable.parser.getComposableTabularReportFileParser\n// com.jayasuryat.mendable.parser.getModuleMetricsFileParser\n// com.jayasuryat.mendable.parser.getComposeCompilerMetricsParser\n\nval composables: ComposableSignaturesReportFile = TODO()\nval composablesParser: ComposableSignaturesReportFileParser = getComposableSignaturesReportFileParser()\nval parsedComposables: ComposableSignaturesReport = composablesParser.parse(composables)\n\nval classes: ClassStabilityReportFile = TODO()\nval classesParser: ClassStabilityReportFileParser = getClassStabilityReportFileParser()\nval parsedClasses: ClassStabilityReport = classesParser.parse(classes)\n\nval tabularReport: ComposableTabularReportFile = TODO()\nval tabularReportParser: ComposableTabularReportFileParser = getComposableTabularReportFileParser()\nval parsedTabularReport: ComposableTabularReport = tabularReportParser.parse(tabularReport)\n\nval moduleMetrics: ModuleMetricsFile = TODO()\nval moduleMetricsParser: ModuleMetricsFileParser = getModuleMetricsFileParser()\nval parsedModuleMetrics: ModuleMetrics = moduleMetricsParser.parse(moduleMetrics)\n\nval someReport: ComposeCompilerMetricsFile = TODO()\nval allParser: ComposeCompilerMetricsParser = getComposeCompilerMetricsParser()\nval report1 = allParser.parser(someReport)\nval report2 = allParser.parser(composables)\nval report3 = allParser.parser(classes)\nval report4 = allParser.parser(tabularReport)\nval report5 = allParser.parser(moduleMetrics)\n</code></pre>"},{"location":"howto/Library/#mendable","title":"<code>:mendable</code>","text":"<p>Mendable exposes a single report generator class which takes in a request and generates a <code>HTML</code> or <code>Json</code> report (based on the request) and saves it to file system.</p> <pre><code>// import com.jayasuryat.mendable.MendableReportGenerator\n// import com.jayasuryat.mendable.MendableReportGeneratorRequest\n\nval request = MendableReportGeneratorRequest(\n    scanPath = \"your input path\",\n    scanRecursively = false,\n    outputPath = \"your output path\",\n    outputFileName = \"reportName\",\n    exportType = ExportType.HTML, // Can also be ExportType.JSON\n    includeModules = IncludeModules.ALL, // Can also be IncludeModules.WITH_WARNINGS\n)\n\nval generator = MendableReportGenerator()\n\n// This is a suspending function\nval result = MendableReportGenerator.Progress.Result =\n    generator.generate(request = request)\n\n// Also, there is an overload which notifies of the progress\n// This is also suspending function\nval result: MendableReportGenerator.Progress.Result =\n    generator.generate(request = request) { progress -&gt;\n        println(progress)\n    }\n</code></pre>"},{"location":"others/Acknowledgements/","title":"Acknowledgements","text":"<p>Huge thanks to Shreyas Patil. A significant portion of this repo has been inspired by his version of compose-report-to-html CLI tool.</p>"},{"location":"others/HowToGenerate/","title":"How to generate Compose Compiler Metrics?","text":"<p>Add the following lines to your root project's <code>build.gradle</code> file. This will direct the Compose compiler to  generate metrics and save all of them into the root project's <code>build folder</code> (for all of the <code>modules</code>).</p> KotlinGroovy build.gradle.kts (root)<pre><code>allprojects {\n    tasks.withType(org.jetbrains.kotlin.gradle.dsl.KotlinCompile::class.java).configureEach {\n        kotlinOptions {\n            // Trigger this with:\n            // ./gradlew assembleRelease -PenableMultiModuleComposeReports=true --rerun-tasks\n            if (project.findProperty(\"enableMultiModuleComposeReports\") == \"true\") {\n                freeCompilerArgs += listOf(\"-P\", \"plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=\" + rootProject.buildDir.absolutePath + \"/compose_metrics/\")\n                freeCompilerArgs += listOf(\"-P\", \"plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=\" + rootProject.buildDir.absolutePath + \"/compose_metrics/\")\n            }\n        }\n    }\n}\n</code></pre> build.gradle (root)<pre><code>subprojects {\n    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {\n        kotlinOptions {\n            // Trigger this with:\n            // ./gradlew assembleRelease -PenableMultiModuleComposeReports=true --rerun-tasks\n            if (project.findProperty(\"enableMultiModuleComposeReports\") == \"true\") {\n                freeCompilerArgs += [\"-P\", \"plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=\" + rootProject.buildDir.absolutePath + \"/compose_metrics/\"]\n                freeCompilerArgs += [\"-P\", \"plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=\" + rootProject.buildDir.absolutePath + \"/compose_metrics/\"]\n            }\n        }\n    }\n}\n</code></pre> <p>With the above setup, you can generate Compose compiler metrics by executing the following <code>command</code> in the <code>terminal</code> window.</p> <pre><code>./gradlew assembleRelease -PenableMultiModuleComposeReports=true --rerun-tasks\n</code></pre>"},{"location":"others/WhatAreJCCM/","title":"What are Jetpack Compose compiler metrics?","text":"<p>The <code>Compose</code> <code>Compiler plugin</code> can generate <code>reports/metrics</code> around certain Compose-specific concepts that can be useful in understanding what is happening with some of the <code>Compose</code> code at a fine-grained level.</p> <p>It can output various performance-related <code>metrics</code> at build time, allowing us to peek behind the curtains and see where any potential <code>performance issues</code> are.</p> <p>Reed more about how to interpret these metrics here &amp; here</p>"},{"location":"others/WhyMendable/","title":"Why HTML / JSON reports","text":"<p>Although, the <code>metrics</code> generated by the <code>Compose Compiler</code> are in pseudo-Kotlin style function signatures, which are reasonably readable. But, over time these files get big and unwieldy to work with, and checking each-and-every <code>composable</code> in those <code>txt files</code> becomes cumbersome and clumsy. Also, these reports are spread across different <code>files</code> for different <code>modules</code>.</p> <p>That is where Mendable comes in and takes care of generating <code>HTML or  JSON reports</code> for <code>Compose</code> <code>compiler metrics</code>, which are much easier to work with. And Mendable only presents <code>composable</code> methods which need your attention, and highlights the issue-causing part with appropriate colors. It filters out the rest of the <code>composables</code> which are non-problematic.</p> <p>Mendable also takes reports of <code>multiple modules</code> and merges them into a single beautiful <code>HTML page</code> or a cohesive <code>JSON report</code> to reduce going back and forth while working.</p> <p><code>HTML</code> reports provide a <code>glanceable</code> &amp; <code>actionable</code> view over which <code>composables</code> are <code>unstable</code>, suitable for identifying and fixing performance related issues.</p> <p><code>JSON</code> reports are more suitable for having an overview of how many composables are present and what percentage of them are stable. <code>Json</code> format is more suitable for enabling checks in <code>CI pipelines</code>. And furthermore, these <code>.json</code> outputs could be committed to the <code>VCS</code> to track stability characteristics changes over time.</p>"}]}